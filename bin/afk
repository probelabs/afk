#!/usr/bin/env node
// afk — AFK toggle + Telegram approvals for Claude Code (Slim Version)
// Thin router using service architecture for clean separation of concerns.

const fs = require('fs');
const os = require('os');
const path = require('path');

// Core modules
const { ConfigManager, readMode, writeMode, modeCmd, cfg } = require('../lib/core/config');
const { Logger, isDebugEnabled, debugLog, eprint } = require('../lib/core/logger');
const { Utils, ensureDir, ensureExecutable, toPosix } = require('../lib/core/utils');

// Service modules
const { TelegramService } = require('../lib/services/telegram');
const { PermissionsService } = require('../lib/services/permissions');
const { SessionsService } = require('../lib/services/sessions');
const { QueueService } = require('../lib/services/queue');
const { InstallService } = require('../lib/services/install');

// Integration modules
const { ClaudeHooksService } = require('../lib/integration/claude-hooks');
const { PromptsService } = require('../lib/ui/prompts');
const { CLIService } = require('../lib/ui/cli');

// ---------------------------
// Constants & paths
// ---------------------------
const HOME = os.homedir();
const USER_CFG_DIR = path.join(HOME, '.afk');

// ---------------------------
// Service initialization
// ---------------------------
const configManager = new ConfigManager();
const logger = new Logger(configManager.configDir);
const utils = Utils; // Utils is a class with static methods, not an instance
const telegramService = new TelegramService(configManager, logger);
const permissionsService = new PermissionsService(configManager, logger);
const sessionsService = new SessionsService(configManager, logger, utils);
const queueService = new QueueService(configManager, logger, utils);
const installService = new InstallService(configManager, permissionsService, logger, utils);
const claudeHooksService = new ClaudeHooksService(
  configManager, 
  telegramService, 
  permissionsService, 
  sessionsService, 
  queueService, 
  logger, 
  utils
);
const promptsService = new PromptsService(configManager, telegramService, logger, utils);
const cliService = new CLIService(configManager, logger, utils);

// ---------------------------
// Utility functions
// ---------------------------
function readStdinJson() {
  return new Promise((resolve, reject) => {
    let input = '';
    process.stdin.on('data', chunk => input += chunk);
    process.stdin.on('end', () => {
      try {
        resolve(JSON.parse(input));
      } catch (e) {
        reject(new Error(`Failed to parse JSON: ${e.message}`));
      }
    });
  });
}

function isInstalled() {
  const userSettingsPath = path.join(HOME, '.claude', 'settings.json');
  if (fs.existsSync(userSettingsPath)) {
    try {
      const settings = JSON.parse(fs.readFileSync(userSettingsPath, 'utf8'));
      return settings.hooks && Array.isArray(settings.hooks.PreToolUse) && settings.hooks.PreToolUse.length > 0;
    } catch (e) {
      return false;
    }
  }
  return false;
}

// ---------------------------
// Command routing
// ---------------------------
async function main() {
  // Write default config if needed
  configManager.writeDefaultConfig();
  
  const argv = process.argv.slice(2);
  const cmd = argv[0];
  
  // Smart toggle behavior: no arguments
  if (!cmd) { 
    if (!isInstalled()) {
      console.log("Run 'afk install' to set up hooks");
      return;
    }
    // If installed, act like toggle command
    configManager.modeCommand('toggle', debugLog);
    return;
  }

  // Command routing
  switch (cmd) {
    case 'install': {
      const scopeIdx = argv.indexOf('--scope');
      let scope = scopeIdx >= 0 ? argv[scopeIdx + 1] : null;
      const prIdx = argv.indexOf('--project-root');
      let projectRoot = prIdx >= 0 ? argv[prIdx + 1] : null;

      if (!scope || !['user','project','local'].includes(scope)) {
        console.log('No scope provided. Choose install scope:');
        scope = await promptsService.promptScope();
      }
      if ((scope === 'project' || scope === 'local') && !projectRoot) {
        projectRoot = await promptsService.promptProjectRoot();
      }

      // If config is incomplete, offer interactive setup first
      const config = configManager.cfg();
      if (!config.telegram_bot_token || !config.telegram_chat_id) {
        console.log('Telegram not configured. Launching interactive setup...');
        await promptsService.showSetupWizard();
      }
      installService.install(scope, projectRoot);
      break;
    }

    case 'uninstall': {
      const scopeIdx = argv.indexOf('--scope');
      const scope = scopeIdx >= 0 ? argv[scopeIdx + 1] : null;
      if (!scope || !['user','project','local'].includes(scope)) { 
        eprint('Missing or invalid --scope'); 
        process.exit(2); 
      }
      installService.uninstall(scope);
      break;
    }

    case 'debug': {
      const subcmd = argv[1];
      const debugFile = path.join(USER_CFG_DIR, '.debug');
      if (subcmd === 'on') {
        fs.writeFileSync(debugFile, '1');
        console.log('✅ Debug mode enabled persistently');
        console.log('Debug log: ~/.afk/debug.log');
      } else if (subcmd === 'off') {
        if (fs.existsSync(debugFile)) fs.unlinkSync(debugFile);
        console.log('✅ Debug mode disabled');
      } else {
        const enabled = fs.existsSync(debugFile);
        console.log(`Debug mode: ${enabled ? 'ENABLED' : 'DISABLED'}`);
        if (enabled) console.log('Debug log: ~/.afk/debug.log');
      }
      break;
    }

    case 'mode': {
      configManager.modeCommand(argv[1] || 'status', debugLog);
      break;
    }

    case 'telegram': {
      const action = argv[1];
      if (action === 'test') {
        const [ok, err] = await telegramService.sendMessageLegacy('afk test message');
        console.log(ok ? 'Test message sent to Telegram.' : `Test failed: ${err}. Re-run \`afk setup\` to fix.`);
      } else {
        cliService.showHelp();
      }
      break;
    }

    case 'hook': {
      const event = argv[1];
      if (event === 'pretooluse') {
        const data = await readStdinJson();
        await claudeHooksService.handlePreToolUse(data);
      } else if (event === 'stop') {
        const data = await readStdinJson();
        await claudeHooksService.handleStop(data);
      } else if (event === 'sessionstart') {
        const data = await readStdinJson();
        await claudeHooksService.handleSessionStart(data);
      } else if (event === 'userpromptsubmit') {
        const data = await readStdinJson();
        const result = await claudeHooksService.handleUserPromptSubmit(data);
        process.stdout.write(JSON.stringify(result));
      } else {
        cliService.showHelp();
      }
      break;
    }

    case 'setup': {
      await promptsService.showSetupWizard();
      break;
    }

    case 'inbox': {
      const subcmd = argv[1];
      if (subcmd === 'wait') {
        const sidIdx = argv.indexOf('--session');
        const sessionId = sidIdx >= 0 ? argv[sidIdx + 1] : null;
        const toIdx = argv.indexOf('--timeout');
        const timeout = toIdx >= 0 ? Number(argv[toIdx + 1]) : 21600;
        if (!sessionId) { 
          eprint('inbox wait requires --session <id>'); 
          process.exit(2); 
        }
        const result = promptsService.waitForInboxEvent({ sessionId, kinds: ['reply','continue'], timeout });
        if (result) {
          console.log(JSON.stringify(result));
        } else {
          console.log('null');
          process.exit(1);
        }
      } else {
        cliService.showHelp();
      }
      break;
    }

    case 'on':
    case 'off':
    case 'readonly':
    case 'toggle':
    case 'status': {
      // Direct mode commands: afk on, afk off, afk readonly, afk toggle, afk status
      configManager.modeCommand(cmd, debugLog);
      break;
    }

    default: {
      cliService.showHelp();
      break;
    }
  }
}

// ---------------------------
// Error handling and startup
// ---------------------------
main().catch(e => { 
  eprint('Fatal:', e.stack || e.message); 
  process.exit(1); 
});